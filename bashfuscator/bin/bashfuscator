#!/usr/bin/env python3

from argparse import ArgumentTypeError, ArgumentParser, FileType
from collections import OrderedDict
from subprocess import STDOUT, PIPE, Popen
from sys import exit, stdin
import re

from argcomplete import autocomplete
import pyperclip

from bashfuscator.common.colors import bold
from bashfuscator.common.messages import activateQuietMode, printInfo, printError
from bashfuscator.core.mutator_list import commandObfuscators, stringObfuscators, tokenObfuscators, encoders, compressors
from bashfuscator.core.obfuscation_handler import ObfuscationHandler


def check_positive(value):
    ivalue = int(value)
    if ivalue <= 0:
         raise ArgumentTypeError("{ivalue} is an invalid positive int value".format(ivalue))
    return ivalue


def getMutators(prefix, parsed_args, **kwargs):
    """
    Returns a list of all mutator's longName attribute for
    auto-completion in cli
    """
    mutatorNames = []
    allMutators = commandObfuscators + stringObfuscators + tokenObfuscators + encoders + compressors
    for mutator in allMutators:
        mutatorNames.append(mutator.longName)

    return mutatorNames


def getMutatorsAndStubs(prefix, parsed_args, **kwargs):
    """
    Returns a list of all mutator's longName attribute, and every
    longName attribute of each CommandObfuscator's stubs for 
    auto-completion in cli
    """
    mutatorNames = []
    for cmdOb in commandObfuscators:
        for stub in cmdOb.stubs:
            mutatorNames.append(cmdOb.longName + "/" + stub.longName)

    mutators = stringObfuscators + tokenObfuscators + encoders + compressors
    for mutator in mutators:
        mutatorNames.append(mutator.longName)
    
    return mutatorNames


def listMutators():
    print(bold("Command Obfuscators:"))
    listMutatorType(commandObfuscators)

    print(bold("\nString Obfuscators:"))
    listMutatorType(stringObfuscators)

    print(bold("\nToken Obfuscators:"))
    listMutatorType(tokenObfuscators)

    print(bold("\nEncoders:"))
    listMutatorType(encoders)

    print(bold("\nCompressors:"))
    listMutatorType(compressors)


def listMutatorType(mutators):
    for mutator in mutators:
        print(bold("\nName: {0}".format(mutator.name)))
        print("Description: {0}".format(mutator.description))
        print("Size Rating: {0}".format(mutator.sizeRating))
        print("Time Rating: {0}".format(mutator.timeRating))
        if mutator.mutatorType != "command":
            if mutator.binariesUsed:
                    binariesUsedString = "".join(b + ", " for b in mutator.binariesUsed)[:-2]
            else:
                binariesUsedString = "None"

            print("Binaries used: {0}".format(binariesUsedString))

        print("File write: {0}".format(mutator.fileWrite))
        if mutator.notes is not None: print("Notes: {0}".format(mutator.notes))
        if mutator.author is not None: print("Author: {0}".format(mutator.author))
        if mutator.credits is not None: 
            print("Credits: ", end="")

            for idx, credit in enumerate(mutator.credits):
                if idx == 0:
                    print(credit)
                else:
                    print(" "*9 + credit)

        if mutator.mutatorType == "command":
            print("\nStubs:")
            for stub in mutator.stubs:
                print("\n\tName: {0}".format(stub.name))

                if stub.binariesUsed:
                    binariesUsedString = "".join(b + ", " for b in stub.binariesUsed)[:-2]
                else:
                    binariesUsedString = "None"

                print("\tBinaries Used: {0}".format(binariesUsedString))
                print("\tSize Rating: {0}".format(stub.sizeRating))
                print("\tTime Rating: {0}".format(stub.timeRating))


def checkRangeArgs(argName, argValue):
    if argValue.find(",") == -1:
        printError("Invalid value for {0} option: format is NUM,NUM".format(argName))
    
    rangeValues = *(int(x) for x in argValue.split(",")),

    if rangeValues[0] < 0 or rangeValues[1] < 0:
        printError("Invalid value for {0} option: range values must be positive".format(argName))

    if rangeValues[0] > rangeValues[1]:
        printError("Invalid value for {0} option: invalid range".format(argName))

    return rangeValues


if __name__ == "__main__":
    parser = ArgumentParser()
    progOpts = parser.add_argument_group("Program Options")
    inptOpts = progOpts.add_mutually_exclusive_group()
    progOpts.add_argument("-l", "--list", action="store_true", help="List all the availible obfuscators, compressors, encoders, and encryptors")
    inptOpts.add_argument("-c", "--command", type=str, help="Command to obfuscate")
    inptOpts.add_argument("-f", "--file", type=str, help="Name of the script to obfuscate. Use '-' if you want to obfuscate stdin")
    progOpts.add_argument("-o", "--outfile", type=str, help="File to write payload to")
    progOpts.add_argument("-q", "--quiet", action="store_true", help="Print only the payload")
    progOpts.add_argument("--clip", action="store_true", help="Copy the payload to clipboard")
    progOpts.add_argument("--test", action="store_true", help="Test the payload after running it. Not compatible with -q")

    obOpts = parser.add_argument_group("Obfuscation Options")
    sizeOpts = obOpts.add_mutually_exclusive_group()
    sizeOpts.add_argument("-s", "--payload-size", default=2, type=int, choices=range(1, 4), help="Desired size of the payload. Default: 2")
    sizeOpts.add_argument("-sm", "--min-payload-size", action="store_true", help="Generate the smallest payload possible")
    sizeOpts.add_argument("-sM", "--max-payload-size", action="store_true", help="Generate the largest payload possible")
    timeOpts = obOpts.add_mutually_exclusive_group()
    timeOpts.add_argument("-t", "--execution-time", default=2, type=int, choices=range(1, 4), help="Desired speed of the payload. Default: 2")
    timeOpts.add_argument("-tm", "--min-execution-time", action="store_true", help="Generate the fastest payload possible")
    timeOpts.add_argument("-tM", "--max-execution-time", action="store_true", help="Generate the slowest payload possible")
    obOpts.add_argument("--layers", type=check_positive, help="Number of layers of obfuscation to apply. Default is 1 when --choose-mutators is used, otherwise: 2")
    binOpts = obOpts.add_mutually_exclusive_group()
    binOpts.add_argument("--include-binaries", nargs="+", type=str, metavar="BINARIES", help="Binaries you exclusively want used in the generated payload")
    binOpts.add_argument("--exclude-binaries", nargs="+", type=str, metavar="BINARIES", help="Binaries you don't want to be used in the generated payload")
    obOpts.add_argument("--no-file-write", action="store_false", help="Don't use obfuscators that require writing to files")

    advancedOpts = parser.add_argument_group("Advanced Options")
    chooseOpts = advancedOpts.add_mutually_exclusive_group()
    chooseOpts.add_argument("--choose-mutators", nargs="+", metavar="MUTATOR", help="Manually choose what mutators are used in what order").completer = getMutators
    chooseOpts.add_argument("--choose-all", nargs="+", metavar="MUTATOR", help="Manually choose what mutators and their stubs if applicable").completer = getMutatorsAndStubs
    advancedOpts.add_argument("--no-binary-mangling", action="store_false", help="Don't obfuscate binary/builtin names")
    advancedOpts.add_argument("--binary-mangle-percent", type=int, choices=range(1, 101), metavar="{1..100}", help="Percentage of chars of binary/builtin names to mangle")
    advancedOpts.add_argument("--no-random-whitespace", action="store_false", help="Don't randomly add whitespace")
    advancedOpts.add_argument("--random-whitespace-range", type=str, metavar="NUM,NUM", help="The range of random whitespace to add")
    advancedOpts.add_argument("--no-insert-chars", action="store_false", help="Don't randomly add variables and characters that Bash ignores")
    advancedOpts.add_argument("--insert-chars-range", type=str, metavar="NUM,NUM", help="The range of random variables and characters to add")
    advancedOpts.add_argument("--no-misleading-commands", action="store_false", help="Don't randomly insert misleading commands that do nothing")
    advancedOpts.add_argument("--misleading-commands-range", type=str, metavar="NUM,NUM", help="The range of random misleading commands to add")
    advancedOpts.add_argument("--write-dir", default="/tmp/", type=str, help="Directory to use if Mutators need to write to or create files")
    advancedOpts.add_argument("--full-ascii-strings", action="store_true", help="Use the full ASCII character set (with a few exceptions) when generating random strings")

    autocomplete(parser)
    args = parser.parse_args()

    if args.list:
        listMutators()
        exit(0)

    if not args.command and not args.file:
        parser.print_usage()
        print("bashfuscator: error: one of the arguments -c/--command -f/--file is required")
        exit(1)

    if args.quiet and args.test:
        parser.print_usage()
        print("bashfuscator: error: argument --test: not allowed with argument -q/--quiet")
        exit(1)

    if args.quiet:
        activateQuietMode()

    if args.min_payload_size:
        args.payload_size = 0
    elif args.max_payload_size:
        args.payload_size = 4

    if args.min_execution_time:
        args.execution_time = 0
    elif args.max_execution_time:
        args.execution_time = 4

    if args.layers is None:
        if args.choose_mutators is not None or args.choose_all is not None:
            args.layers = 1
        else:
            args.layers = 2

    if args.include_binaries is not None:
        args.binaryPref = (args.include_binaries, True)
    elif args.exclude_binaries is not None:
        args.binaryPref = (args.exclude_binaries, False)
    else:
        args.binaryPref = None
    
    shebang = ""
    if args.file:
        if args.file == "-":
            args.command = stdin.read()
        else:
            with open(args.file, "rb") as infile:
                firstLine = infile.readline().decode("utf-8")
                if re.match(r"\s*#!", firstLine) is not None:
                    shebang = firstLine
                else:
                    infile.seek(0)

                args.command = infile.read().decode("utf-8")

    if args.random_whitespace_range:
        args.random_whitespace_range = checkRangeArgs("--random-whitespace-range", args.random_whitespace_range)
    if args.insert_chars_range:
        args.insert_chars_range = checkRangeArgs("--insert_chars_range", args.insert_chars_range)
    if args.misleading_commands_range:
        args.misleading_commands_range = checkRangeArgs("--misleading_commands_range", args.misleading_commands_range)

    if args.write_dir[-1:] != "/":
        args.write_dir += "/"

    obHandler = ObfuscationHandler(args=args)
    payload = obHandler.generatePayload()

    if args.outfile:
        with open(args.outfile, "wb") as outfile:
            if shebang != "":
                outfile.write(shebang.encode("utf-8"))
            
            outfile.write(payload.encode("utf-8"))

        printInfo("Payload written to {0}".format(args.outfile))

    if args.clip:
        pyperclip.copy(payload)
        printInfo("Payload copied to clipboard\n")

    printInfo("Payload:\n")
    print(payload)
    
    if not args.quiet:
        print("")

    printInfo("Payload size: {0} characters".format(len(payload)))

    if args.test:
        printInfo("Testing payload:\n")
        if args.outfile:
            proc = Popen(["bash", args.outfile], stdout=PIPE, stderr=STDOUT, shell=False, universal_newlines=True)
            stdout, __ = proc.communicate()
            print(stdout)
        else:
            proc = Popen(payload, executable="bash", stdout=PIPE, stderr=STDOUT, shell=True, universal_newlines=True)
            stdout, __ = proc.communicate()
            print(stdout)  
