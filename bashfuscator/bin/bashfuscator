#!/usr/bin/env python3

from argparse import ArgumentTypeError, ArgumentParser, FileType
from collections import OrderedDict
from subprocess import STDOUT, PIPE, Popen
from sys import exit
import re

from argcomplete import autocomplete
import pyperclip

from bashfuscator.common.colors import bold
from bashfuscator.common.messages import activateQuietMode, printInfo
from bashfuscator.core.obfuscation_handler import ObfuscationHandler
from bashfuscator.lib.command_obfuscators import *
from bashfuscator.lib.string_obfuscators import *
from bashfuscator.lib.token_obfuscators import *
from bashfuscator.lib.encoders import *
from bashfuscator.lib.compressors import *


commandObfuscators = [
    CaseSwap(),
    ForCode(),
    Reverse(),
]

stringObfuscators = [
    FileGlob(),
    FolderGlob(),
    HexHash(),
]

tokenObfuscators = [
    AnsiCQuote(),
]

encoders = [
    Base64(),
    UrlEncode(),
]

compressors = [
    Bzip2(),
    Gzip(),
]


def check_positive(value):
    ivalue = int(value)
    if ivalue <= 0:
         raise ArgumentTypeError("{ivalue} is an invalid positive int value".format(ivalue))
    return ivalue


def getMutators(prefix, parsed_args, **kwargs):
    """
    Returns a list of all mutator's longName attribute for
    auto-completion in cli
    """
    mutatorNames = []
    allMutators = commandObfuscators + stringObfuscators + tokenObfuscators + encoders + compressors
    for mutator in allMutators:
        mutatorNames.append(mutator.longName)

    return mutatorNames


def getMutatorsAndStubs(prefix, parsed_args, **kwargs):
    """
    Returns a list of all mutator's longName attribute, and every
    longName attribute of each CommandObfuscator's stubs for 
    auto-completion in cli
    """
    mutatorNames = []
    for cmdOb in commandObfuscators:
        for stub in cmdOb.stubs:
            mutatorNames.append(cmdOb.longName + "/" + stub.longName)

    mutators = stringObfuscators + tokenObfuscators + encoders + compressors
    for mutator in mutators:
        mutatorNames.append(mutator.longName)
    
    return mutatorNames


def listMutators():
    print(bold("Command Obfuscators:"))
    listMutatorType(commandObfuscators)

    print(bold("\nString Obfuscators:"))
    listMutatorType(stringObfuscators)

    print(bold("\nToken Obfuscators:"))
    listMutatorType(tokenObfuscators)

    print(bold("\nEncoders:"))
    listMutatorType(encoders)

    print(bold("\nCompressors:"))
    listMutatorType(compressors)


def listMutatorType(mutators):
    for mutator in mutators:
        print(bold("\nName: {0}".format(mutator.name)))
        print("Description: {0}".format(mutator.description))
        print("Size Rating: {0}".format(mutator.sizeRating))
        if mutator.mutatorType != "token": print("Time Rating: {0}".format(mutator.timeRating))
        if mutator.notes is not None: print("Notes: {0}".format(mutator.notes))
        if mutator.author is not None: print("Author: {0}".format(mutator.author))
        if mutator.credits is not None: print("Credits: {0}".format(mutator.credits))

        if mutator.mutatorType == "command":
            print("\nStubs:")
            for stub in mutator.stubs:
                print("\n\tName: {0}".format(stub.name))
                print("\tBinaries Used: {0}".format("".join(b + ", " for b in stub.binariesUsed)[:-2]))
                print("\tSize Rating: {0}".format(stub.sizeRating))
                print("\tTime Rating: {0}".format(stub.timeRating))


if __name__ == "__main__":
    parser = ArgumentParser()
    progOpts = parser.add_argument_group("Program Options")
    inptOpts = progOpts.add_mutually_exclusive_group(required=True)
    inptOpts.add_argument("-l", "--list", action="store_true", help="List all the availible obfuscators, compressors, encoders, and encryptors")
    inptOpts.add_argument("-c", "--command", type=str, help="Command to obfuscate")
    inptOpts.add_argument("-f", "--file", type=str, help="Name of the script to obfuscate")
    #inptOpts.add_argument("--stdin", action="store_true", help="Receive command to obfuscate from stdin")
    progOpts.add_argument("-o", "--outfile", type=str, help="File to write payload to")
    progOpts.add_argument("-q", "--quiet", action="store_true", help="Print only the payload")

    obOpts = parser.add_argument_group("Obfuscation Options")
    sizeOpts = obOpts.add_mutually_exclusive_group()
    sizeOpts.add_argument("-s", "--payload-size", default=2, type=int, choices=range(1, 4), help="Desired size of the payload. Default: 2")
    sizeOpts.add_argument("-sm", "--min-payload-size", action="store_true", help="Generate the smallest payload possible")
    sizeOpts.add_argument("-sM", "--max-payload-size", action="store_true", help="Generate the largest payload possible")
    timeOpts = obOpts.add_mutually_exclusive_group()
    timeOpts.add_argument("-t", "--execution-time", default=2, type=int, choices=range(1, 4), help="Desired speed of the payload. Default: 2")
    timeOpts.add_argument("-tm", "--min-execution-time", action="store_true", help="Generate the fastest payload possible")
    timeOpts.add_argument("-tM", "--max-execution-time", action="store_true", help="Generate the slowest payload possible")

    advancedOpts = parser.add_argument_group("Advanced Options")
    chooseOpts = advancedOpts.add_mutually_exclusive_group()
    chooseOpts.add_argument("--choose-mutators", nargs="+", metavar="MUTATOR", help="Manually choose what mutators are used in what order").completer = getMutators
    chooseOpts.add_argument("--choose-all", nargs="+", metavar="MUTATOR", help="Manually choose what mutators and their stubs if applicable").completer = getMutatorsAndStubs
    advancedOpts.add_argument("--layers", type=check_positive, help="Number of layers of obfuscation to apply. Default is 1 when --choose-mutators is used, otherwise: 2")
    binOpts = advancedOpts.add_mutually_exclusive_group()
    binOpts.add_argument("--include-binaries", nargs="+", type=str, metavar="BINARIES", help="Binaries you exclusively want used in the generated payload")
    binOpts.add_argument("--exclude-binaries", nargs="+", type=str, metavar="BINARIES", help="Binaries you don't want to used in the generated payload")
    advancedOpts.add_argument("--full-ascii-strings", action="store_true", help="Use the full ASCII character set (with a few exceptions) when generating random strings")
    advancedOpts.add_argument("--no-file-write", action="store_true", help="Don't use obfuscators that require writing to files")
    #advancedOpts.add_argument("--no-minify", action="store_true", help="Don't minify script or command entered before obfuscation")
    advancedOpts = parser.add_argument("--test", action="store_true", help="Test the payload after running it")

    misc = parser.add_argument_group("Misc Options")
    misc.add_argument("--clip", action="store_true", help="Copy the payload to clipboard")

    autocomplete(parser)
    args = parser.parse_args()

    if args.list:
        listMutators()
        exit(0)

    if args.quiet:
        activateQuietMode()

    if args.min_payload_size:
        args.payload_size = 0
    elif args.max_payload_size:
        args.payload_size = 4

    if args.min_execution_time:
        args.execution_time = 0
    elif args.max_execution_time:
        args.execution_time = 4

    if args.include_binaries is not None:
        args.binaryPref = (args.include_binaries, True)
    elif args.exclude_binaries is not None:
        args.binaryPref = (args.exclude_binaries, False)
    else:
        args.binaryPref = None

    if args.layers is None:
        if args.choose_mutators is not None:
            args.layers = 1
        else:
            args.layers = 2
    
    shebang = ""
    if args.file:
        with open(args.file, "rb") as infile:
            firstLine = infile.readline().decode("utf-8")
            if re.match(r"\s*#!", firstLine) is not None:
                shebang = firstLine
            else:
                infile.seek(0)

            args.command = infile.read().decode("utf-8")

    obHandler = ObfuscationHandler(commandObfuscators, stringObfuscators, tokenObfuscators, encoders, compressors, args)
    payload = obHandler.generatePayload()

    if args.outfile:
        with open(args.outfile, "wb") as outfile:
            if shebang != "":
                outfile.write(shebang.encode("utf-8"))
            
            outfile.write(payload.encode("utf-8"))

        printInfo("Payload written to {0}".format(args.outfile))

    if args.clip:
        pyperclip.copy(payload)
        printInfo("Payload copied to clipboard\n")

    printInfo("Payload:\n")
    print(payload)
    
    if not args.quiet:
        print("")

    printInfo("Payload size: {0} characters".format(len(payload)))

    if args.test:
        printInfo("Testing payload:\n")
        if args.outfile:
            proc = Popen(["bash", args.outfile], stdout=PIPE, stderr=STDOUT, shell=False, universal_newlines=True)
            stdout, __ = proc.communicate()
            print(stdout)
        else:
            proc = Popen(payload, executable="/bin/bash", stdout=PIPE, stderr=STDOUT, shell=True, universal_newlines=True)
            stdout, __ = proc.communicate()
            print(stdout)  
